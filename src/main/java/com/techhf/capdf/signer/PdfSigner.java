package com.techhf.capdf.signer;

import org.apache.pdfbox.pdmodel.PDDocument;
import org.apache.pdfbox.pdmodel.interactive.digitalsignature.PDSignature;
import org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureInterface;
import org.apache.pdfbox.pdmodel.interactive.digitalsignature.SignatureOptions;
import org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSigProperties;
import org.apache.pdfbox.pdmodel.interactive.digitalsignature.visible.PDVisibleSignDesigner;
import org.bouncycastle.asn1.ASN1ObjectIdentifier;
import org.bouncycastle.asn1.cms.AttributeTable;
import org.bouncycastle.asn1.pkcs.PKCSObjectIdentifiers;
import org.bouncycastle.cert.jcajce.JcaCertStore;
import org.bouncycastle.cms.*;
import org.bouncycastle.cms.jcajce.JcaSignerInfoGeneratorBuilder;
import org.bouncycastle.jce.provider.BouncyCastleProvider;
import org.bouncycastle.operator.ContentSigner;
import org.bouncycastle.operator.jcajce.JcaContentSignerBuilder;
import org.bouncycastle.operator.jcajce.JcaDigestCalculatorProviderBuilder;
import org.bouncycastle.tsp.*;
import org.bouncycastle.util.Store;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.*;
import java.math.BigInteger;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.Security;
import java.security.cert.Certificate;
import java.security.cert.X509Certificate;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Date;

/**
 * PDF签名器
 * 支持可视化签章和时间戳
 */
public class PdfSigner {
    
    private static final Logger logger = LoggerFactory.getLogger(PdfSigner.class);
    
    static {
        if (Security.getProvider(BouncyCastleProvider.PROVIDER_NAME) == null) {
            Security.addProvider(new BouncyCastleProvider());
        }
    }

    /**
     * 对PDF进行数字签名（带可视化签章）
     * 
     * @param inputPdf 输入PDF文件
     * @param outputPdf 输出PDF文件
     * @param certPath 证书路径(.p12)
     * @param password 证书密码（可以为null或空字符串表示无密码）
     * @param reason 签名原因
     * @param location 签名地点
     * @param signImagePath 签章图片路径（可选，传null则自动生成）
     * @param addTimestamp 是否添加时间戳
     */
    public static void signPdf(
            File inputPdf,
            File outputPdf,
            String certPath,
            String password,
            String reason,
            String location,
            String signImagePath,
            boolean addTimestamp) throws Exception {
        
        logger.info("开始签名PDF: {}", inputPdf.getName());
        
        // 处理空密码情况
        char[] passwordChars = (password == null || password.isEmpty()) ? new char[0] : password.toCharArray();
        
        // 1. 加载证书和私钥
        KeyStore keyStore = KeyStore.getInstance("PKCS12");
        try (FileInputStream fis = new FileInputStream(certPath)) {
            keyStore.load(fis, passwordChars);
        }
        
        String alias = keyStore.aliases().nextElement();
        PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, passwordChars);
        Certificate[] certChain = keyStore.getCertificateChain(alias);
        X509Certificate cert = (X509Certificate) certChain[0];
        
        logger.info("证书加载成功: {}", cert.getSubjectDN());
        
        // 如果没有提供签章图片，自动生成一个
        String actualImagePath = signImagePath;
        boolean autoGeneratedImage = false;
        if (actualImagePath == null || !new File(actualImagePath).exists()) {
            actualImagePath = "auto-generated-signature.png";
            generateSignatureImage(
                    getCommonName(cert.getSubjectDN().getName()),
                    location,
                    reason,
                    actualImagePath
            );
            autoGeneratedImage = true;
            logger.info("自动生成签章图片: {}", actualImagePath);
        }
        
        // 2. 打开PDF文档
        try (PDDocument doc = PDDocument.load(inputPdf);
             FileOutputStream fos = new FileOutputStream(outputPdf)) {
            
            // 3. 创建签名对象
            PDSignature signature = new PDSignature();
            signature.setFilter(PDSignature.FILTER_ADOBE_PPKLITE);
            signature.setSubFilter(PDSignature.SUBFILTER_ADBE_PKCS7_DETACHED);
            signature.setName(getCommonName(cert.getSubjectDN().getName()));
            signature.setReason(reason != null ? reason : "Digital Signature");
            signature.setLocation(location != null ? location : "Default Location");
            signature.setSignDate(Calendar.getInstance());
            
            // 4. 配置签名选项（可视化签章）
            SignatureOptions signatureOptions = new SignatureOptions();
            signatureOptions.setPreferredSignatureSize(SignatureOptions.DEFAULT_SIGNATURE_SIZE * 2);
            
            // 创建可视化签章
            createVisibleSignature(doc, signature, signatureOptions, actualImagePath);
            
            // 5. 注册签名接口
            doc.addSignature(signature, new SignatureInterface() {
                @Override
                public byte[] sign(InputStream content) throws IOException {
                    try {
                        return createSignature(content, privateKey, certChain, addTimestamp);
                    } catch (Exception e) {
                        throw new IOException("签名失败", e);
                    }
                }
            }, signatureOptions);
            
            // 6. 保存签名后的文档
            doc.saveIncremental(fos);
            logger.info("PDF签名完成: {}", outputPdf.getName());
            
            // 删除自动生成的临时图片
            if (autoGeneratedImage) {
                new File(actualImagePath).delete();
            }
        }
    }
    
    /**
     * 自动生成签章图片
     */
    private static void generateSignatureImage(String signerName, String location, String reason, String outputPath) {
        try {
            int width = 300;
            int height = 150;
            
            java.awt.image.BufferedImage image = new java.awt.image.BufferedImage(
                    width, height, java.awt.image.BufferedImage.TYPE_INT_RGB);
            java.awt.Graphics2D g2d = image.createGraphics();
            
            // 抗锯齿
            g2d.setRenderingHint(java.awt.RenderingHints.KEY_ANTIALIASING, 
                               java.awt.RenderingHints.VALUE_ANTIALIAS_ON);
            g2d.setRenderingHint(java.awt.RenderingHints.KEY_TEXT_ANTIALIASING, 
                               java.awt.RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
            
            // 白色背景
            g2d.setColor(java.awt.Color.WHITE);
            g2d.fillRect(0, 0, width, height);
            
            // 蓝色边框
            g2d.setColor(new java.awt.Color(0, 102, 204));
            g2d.setStroke(new java.awt.BasicStroke(3));
            g2d.drawRoundRect(5, 5, width - 10, height - 10, 15, 15);
            
            // 标题
            g2d.setFont(new java.awt.Font("微软雅黑", java.awt.Font.BOLD, 20));
            drawCenteredText(g2d, "数字签名", width / 2, 35);
            
            // 分隔线
            g2d.setColor(new java.awt.Color(200, 200, 200));
            g2d.setStroke(new java.awt.BasicStroke(1));
            g2d.drawLine(20, 50, width - 20, 50);
            
            // 详细信息
            g2d.setColor(java.awt.Color.BLACK);
            g2d.setFont(new java.awt.Font("微软雅黑", java.awt.Font.PLAIN, 13));
            
            int yPos = 75;
            g2d.drawString("签名人: " + signerName, 20, yPos);
            yPos += 25;
            
            if (location != null && !location.isEmpty()) {
                g2d.drawString("位置: " + location, 20, yPos);
                yPos += 25;
            }
            
            g2d.setFont(new java.awt.Font("微软雅黑", java.awt.Font.PLAIN, 11));
            g2d.drawString("时间: " + new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss").format(new Date()), 20, yPos);
            
            g2d.dispose();
            
            // 保存
            javax.imageio.ImageIO.write(image, "PNG", new File(outputPath));
            
        } catch (Exception e) {
            logger.warn("生成签章图片失败，将使用默认样式", e);
        }
    }
    
    /**
     * 居中绘制文本
     */
    private static void drawCenteredText(java.awt.Graphics2D g2d, String text, int x, int y) {
        java.awt.FontMetrics fm = g2d.getFontMetrics();
        int textWidth = fm.stringWidth(text);
        g2d.drawString(text, x - textWidth / 2, y);
    }

    /**
     * 创建可视化签章
     */
    private static void createVisibleSignature(
            PDDocument doc,
            PDSignature signature,
            SignatureOptions options,
            String imagePath) throws IOException {
        
        try (FileInputStream imageStream = new FileInputStream(imagePath)) {
            // 在最后一页的右下角创建签章
            int pageNum = doc.getNumberOfPages() - 1;
            
            PDVisibleSignDesigner designer = new PDVisibleSignDesigner(
                    doc,
                    imageStream,
                    pageNum + 1  // PDFBox页码从1开始
            );
            
            // 设置签章位置和大小
            designer.xAxis(400)   // X坐标
                    .yAxis(50)    // Y坐标
                    .width(150)   // 宽度
                    .height(80)   // 高度
                    .zoom(-50);   // 缩放
            
            PDVisibleSigProperties properties = new PDVisibleSigProperties();
            properties.signerName(signature.getName())
                      .signerLocation(signature.getLocation())
                      .signatureReason(signature.getReason())
                      .preferredSize(0)
                      .page(pageNum)
                      .visualSignEnabled(true)
                      .setPdVisibleSignature(designer)
                      .buildSignature();
            
            options.setVisualSignature(properties);
            options.setPage(pageNum);
            
            logger.info("可视化签章配置完成");
        }
    }

    /**
     * 创建PKCS#7签名数据
     */
    private static byte[] createSignature(
            InputStream content,
            PrivateKey privateKey,
            Certificate[] certChain,
            boolean addTimestamp) throws Exception {
        
        logger.info("生成签名数据...");
        
        // 1. 读取PDF内容
        byte[] pdfContent = readAllBytes(content);
        
        // 2. 创建CMS签名生成器
        CMSSignedDataGenerator gen = new CMSSignedDataGenerator();
        
        X509Certificate cert = (X509Certificate) certChain[0];
        ContentSigner signer = new JcaContentSignerBuilder("SHA256withRSA")
                .setProvider("BC")
                .build(privateKey);
        
        // 3. 构建签名者信息生成器
        JcaSignerInfoGeneratorBuilder signerBuilder = new JcaSignerInfoGeneratorBuilder(
                new JcaDigestCalculatorProviderBuilder()
                        .setProvider("BC")
                        .build());
        
        gen.addSignerInfoGenerator(signerBuilder.build(signer, cert));
        
        // 4. 添加证书链
        Store certStore = new JcaCertStore(Arrays.asList(certChain));
        gen.addCertificates(certStore);
        
        // 5. 生成签名
        CMSSignedData signedData = gen.generate(
                new org.bouncycastle.cms.CMSProcessableByteArray(pdfContent),
                false
        );
        
        // 6. 如果需要，添加时间戳
        if (addTimestamp) {
            logger.info("添加时间戳到签名...");
            signedData = addTimestampToSignature(signedData, privateKey, cert);
        }
        
        byte[] signatureBytes = signedData.getEncoded();
        logger.info("签名数据生成完成，大小: {} bytes", signatureBytes.length);
        return signatureBytes;
    }

    /**
     * 添加时间戳到签名
     * 将时间戳作为 unsigned attribute 添加到 SignerInfo
     */
    private static CMSSignedData addTimestampToSignature(
            CMSSignedData signedData,
            PrivateKey tsaPrivateKey,
            X509Certificate tsaCert) throws Exception {
        
        logger.info("生成时间戳令牌...");
        
        // 获取原始签名信息
        SignerInformationStore signerInfos = signedData.getSignerInfos();
        SignerInformation signerInfo = signerInfos.getSigners().iterator().next();
        
        // 1. 创建时间戳请求
        TimeStampRequestGenerator tsReqGen = new TimeStampRequestGenerator();
        tsReqGen.setCertReq(true);
        
        // 2. 计算签名值的哈希
        byte[] signature = signerInfo.getSignature();
        java.security.MessageDigest md = java.security.MessageDigest.getInstance("SHA-256");
        byte[] signatureHash = md.digest(signature);
        
        // 3. 生成时间戳请求
        TimeStampRequest tsRequest = tsReqGen.generate(
                TSPAlgorithms.SHA256,
                signatureHash,
                BigInteger.valueOf(System.currentTimeMillis())
        );
        
        // 4. 生成时间戳令牌（自签名时间戳）
        TimeStampToken tsToken = generateTimeStampToken(tsRequest, tsaPrivateKey, tsaCert);
        
        logger.info("时间戳生成成功");
        logger.info("时间戳时间: {}", tsToken.getTimeStampInfo().getGenTime());
        
        // 5. 将时间戳作为 unsigned attribute 添加到 SignerInfo
        AttributeTable unsignedAttrs = signerInfo.getUnsignedAttributes();
        if (unsignedAttrs == null) {
            unsignedAttrs = new AttributeTable(new java.util.Hashtable<>());
        }
        
        // 添加时间戳属性（OID: 1.2.840.113549.1.9.16.2.14）
        ASN1ObjectIdentifier tsAttrType = PKCSObjectIdentifiers.id_aa_signatureTimeStampToken;
        
        // RFC 3161: 时间戳令牌必须作为 SignedData ContentInfo 结构存储
        // 直接使用 toCMSSignedData().toASN1Structure() 获取 ContentInfo
        org.bouncycastle.asn1.ASN1Encodable tsContentInfo = tsToken.toCMSSignedData().toASN1Structure();
        
        // 直接添加时间戳属性，不要再次获取 AttrValues（避免嵌套 SET）
        unsignedAttrs = unsignedAttrs.add(tsAttrType, tsContentInfo);
        
        // 6. 重建 SignerInfo
        SignerInformation newSignerInfo = SignerInformation.replaceUnsignedAttributes(signerInfo, unsignedAttrs);
        
        // 7. 重建 CMSSignedData
        SignerInformationStore newSignerInfos = new SignerInformationStore(Arrays.asList(newSignerInfo));
        
        CMSSignedData newSignedData = CMSSignedData.replaceSigners(signedData, newSignerInfos);
        
        logger.info("时间戳已嵌入到签名中");
        return newSignedData;
    }

    /**
     * 生成时间戳令牌（自签名TSA）
     * 注意：生产环境应该调用真实的TSA服务器
     */
    private static TimeStampToken generateTimeStampToken(
            TimeStampRequest request,
            PrivateKey tsaPrivateKey,
            X509Certificate tsaCert) throws Exception {
        
        // 创建摘要计算器提供者
        org.bouncycastle.operator.DigestCalculatorProvider digestCalcProvider = 
                new JcaDigestCalculatorProviderBuilder()
                        .setProvider("BC")
                        .build();
        
        // 创建签名者信息生成器
        ContentSigner signer = new JcaContentSignerBuilder("SHA256withRSA")
                .setProvider("BC")
                .build(tsaPrivateKey);
        
        org.bouncycastle.cms.SignerInfoGenerator signerInfoGen = new JcaSignerInfoGeneratorBuilder(digestCalcProvider)
                .build(signer, tsaCert);
        
        // 创建时间戳令牌生成器
        TimeStampTokenGenerator tsTokenGen = new TimeStampTokenGenerator(
                signerInfoGen,
                digestCalcProvider.get(
                        new org.bouncycastle.operator.DefaultDigestAlgorithmIdentifierFinder().find("SHA-256")
                ),
                new org.bouncycastle.asn1.ASN1ObjectIdentifier("1.2.3.4.5.6.7.8.9") // TSA Policy OID
        );
        
        // 添加证书
        tsTokenGen.addCertificates(new JcaCertStore(Arrays.asList(tsaCert)));
        
        // 生成时间戳响应
        TimeStampResponseGenerator tsRespGen = new TimeStampResponseGenerator(
                tsTokenGen,
                TSPAlgorithms.ALLOWED
        );
        
        TimeStampResponse tsResponse = tsRespGen.generate(
                request,
                BigInteger.valueOf(System.currentTimeMillis()),
                new Date()
        );
        
        // 验证响应
        tsResponse.validate(request);
        
        logger.warn("注意：当前使用自签名时间戳，生产环境请使用真实的TSA服务");
        
        return tsResponse.getTimeStampToken();
    }

    /**
     * 从输入流读取所有字节
     */
    private static byte[] readAllBytes(InputStream input) throws IOException {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        int nRead;
        byte[] data = new byte[16384];
        while ((nRead = input.read(data, 0, data.length)) != -1) {
            buffer.write(data, 0, nRead);
        }
        return buffer.toByteArray();
    }

    /**
     * 从DN中提取CN（通用名称）
     */
    private static String getCommonName(String dn) {
        for (String part : dn.split(",")) {
            if (part.trim().startsWith("CN=")) {
                return part.trim().substring(3);
            }
        }
        return dn;
    }
}
